**Парадигмы программирования:**
- структурные
- Объектно-ориентированные
- Функциональные

**Принципы модульности**
_Модульность(modularity)_ - логическая группировка взаимосвязанного кода, 
который может быть структурирован в классах(ООП) или функциях(функциональная/структурная парадигмы)

_Cohesion_ - метрика, которая показывает до какой степени части модуля должны быть внутри одного модуля/
мера того, как части модуля связаны друг с другом(связи внутри компонента)

_Coupling_ - степень связности между модулями(связи между компонентами)

_Connascence_ - метрика, позволяющая размышлять о сложности, вызванной отношениями зависимости.

**Принципы SOLID**
- S - Single responsibility - для каждого класса должно быть определено единственное назначение
- O - Open/closed - сущности открыты для расширения, но закрыты для модификации
- L - Liskov substitution principle - объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы
- I - interface segregation - много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения
- D - Dependency injection - зависимости должны быть на абстракциях, а не на чем-то кокретном

**Связи SOLID с архитектурой:**

- S - когда дизайним систему, стоит задумываться, как будут выглядеть команды
- O - добавлять код для нового функционала, а не править старый
- L - Систему надо дизайнить из компонент, которые поддерживаются контракта, что делает их взаимозаменяемыми
- I - В дизайне систем надо изменять зависимостей, которые не используются
- D - Код, который имплементирует высокоуровневые политики не должен зависеть от низкоуровневых деталей

**12 factor app**

1) Кодовая база
Одна кодовая база - множество развертываний
2) Зависимости
Явно обновлять и изолировать зависимости
3) Конфигурация
Конфигурацию необходимо хранить в среде выполнения
4) Сторонние службы
Сторонние службы нужно считать подключаемыми ресурсами и работать с ними осмысленно
5) Сборка и выполнение
Стадии сборки и выполнения нужно строго разделять
6) Процессы
Запускать приложение как один или несколько процессов не сохраняющих внутреннее состояние
7) Привязка портов
Приложение должно само слушать приложение на определенном порту
8) Параллелизм
Масштабируйте приложение с помощью процессов
9) Утилизируемость
Приложение должно правильно реагировать на сигнал ОС
10) Паритет разработки
Держать окружения промежуточного развертывания и прод в максимально похожем состоянии
11) Логирование
Журнал как поток событий
12) Задачи администрирования/управления приложением
Выполнять задачи администрирования / управления с помощью разовых процессоров
    



